#!/usr/bin/ruby 
#-rtracer
#
#

require 'date'
require 'hwk'
require 'hwk/hwkfiles'

include Hwk

if ARGV.length < 1 or ARGV[0] == '-h'
  puts
  puts( "usage: [-n name] [open|edit|pdf]")
  puts( "\t-n name\t Create a new name.hwk file, prepopulated")
  puts( "\topen\t Open local .pdf file based on .hwk file.")
  puts( "\tedit\t Edit local .hwk file, currenlty only one.")
  puts( "\tpdf\t Generate and open pdf from local .hwk file.")
  puts( "\thwk\t Edit the hwk binary or some other specified library file.")
  puts
  exit(true)
end

editor = ENV['EDITOR']
editor = 'vi' if editor.nil?
valid_commands = ['open','edit','pdf']
hwk = nil

if ARGV.length > 1 and valid_commands.include?(ARGV[0])
  hwk = Homework.new( ARGV[1] )
  if hwk.files.dsl.nil?
    puts( "Did not find a hwk file in: #{ARGV[1]}" )
    exit(false)
  end
else
  hwk = Homework.new( '.' )
end

if ARGV[0] == "-n"
  if ARGV.length < 2
    abort( " -n requires filename" )
  else
    target = ARGV[1]+'.'+EXTNAME
    source = File.expand_path(File.join(TEMPLATE_DIR,NEW_HWK_FILE))

    result = system( "cp #{source} #{target}" );
    if result == false
      abort("Error copying new hwk template #{source} to #{target}: #{$?}")
    end
    exit(true)
  end
elsif ARGV[0] == "open"
  if hwk.files.pdf.exists?
    status = system( "open \"#{hwk.files.pdf}\"" );
    if status == nil || (status && status != true )
      abort("Error opening: #{$?}")
    end
    exit(true)
  else
    abort("No pdf to open: #{hwk.files.pdf}")
  end
elsif ARGV[0] == "edit"

  if hwk.files.dsl.exists?
    status = system( "#{editor} \"#{hwk.files.dsl}\"" );
    if status == nil || (status && status != true )
      abort("Error editing: #{$?}")
    end
    exit(true)
  else
    abort("No hwk file to open: #{hwk.files.dsl}")
  end
elsif ARGV[0] == 'hwk'
  if ARGV[1].nil?
    hwk_file = HWK_DIR + '/bin/hwk'
  else
    hwk_file = HWK_DIR + '/' + ARGV[1]
  end
  status = system( "#{editor} \"#{File.expand_path(hwk_file)}\"" )
  if status == nil || (status && status != true )
    abort("Error editing: #{$?}")
  end
  exit(true)
elsif ARGV[0] == 'pdf'
  # pass thru to default behavior
end

if hwk.files.dsl.nil? || hwk.files.dsl.exists? == false
  abort( "Now homework found here" )
end

puts "Working on #{hwk.files.dsl}"

#set_trace_func proc{ |event, file, line, id, binding, classname|
#    printf("%8s %s:%-2d %10s %8s\n", event, file, line, id, classname) #if file =~ /my_app_name/ and event == 'return' #show only interesting files
#}


begin
  hwk.load
  hwk.write_tex
rescue StandardError => error
  puts error.backtrace
  location = error.backtrace[0].split(':')[0..1].join(':')
  msg = error.message
  if ( msg.scan(/undefined method/) )
    #msg = "Unrecognized command: #{msg.split[2]}"
  end
  abort( "Error at #{location}: #{msg}" )
rescue SyntaxError => error
  location = error.backtrace[0].split(':')[0..1].join(':')
  msg = error.message
  if ( msg.scan(/syntax error/) )
    #msg = "Syntax error: #{msg.split[2]}"
  end
  abort( "Syntax error at #{location}: #{msg}" )
end

# Clear off any old biblio files
if hwk.files.bbl.exists?
  File.delete hwk.files.bbl
end

result = nil
if hwk.files.tex.exists?
  result = system( "pdflatex -shell-escape -interaction=batchmode \"#{hwk.files.tex}\" >& pdflatex.log" )
end

if result && hwk.parser.bibliography?
  if hwk.files.aux.exists?
    puts "  Generate biblio from #{hwk.files.aux}"
    result = system( "bibtex \"#{hwk.files.aux}\" >& bibtex.log" )
    if result
      puts "  Re-run latex"
      result = system( "pdflatex -shell-escape -interaction=batchmode \"#{hwk.files.tex}\" >& pdflatex.log" )
      if result
        result = system( "pdflatex -shell-escape -interaction=batchmode \"#{hwk.files.tex}\" >& pdflatex.log" )
      end
    end
  else
    abort( "Expected #{hwk.files.aux} to exist for bibliography, but it's missing!" )
  end
end

if ( result == false )
  puts "Error generating PDF from tex file: #{$?}"
else
  puts "Success!  Reopening file!"
  if hwk.files.pdf.exists?
    system( "open \"#{hwk.files.pdf}\"" )
  end
end




